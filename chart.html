<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <link rel="icon" href="./favicon.ico" type="image/x-icon">
  <title>本日の株価</title>
  <!-- MessagePack.js
     (c) 2010-2025 MessagePack project contributors
     MIT License
     https://github.com/msgpack/msgpack-javascript
-->
  <script src="https://cdn.jsdelivr.net/npm/@msgpack/msgpack/dist.es5+umd/msgpack.min.js" defer></script>

  <!-- Plotly.js v2.x
     (c) 2015-2025 Plotly, Inc.
     MIT License
     https://github.com/plotly/plotly.js
-->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <!-- plotly.js locale 日本語（plotly-locale-ja-latest）
     (c) 2025 Plotly, Inc.
     Code released under the MIT License
     Documentation released under Creative Commons License (if applicable)
     Source: https://github.com/plotly/plotly.js-locales
-->
  <script src="https://cdn.plot.ly/plotly-locale-ja-latest.js" defer></script>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }

    #back {
      position: fixed;
      top: 2px;
      left: 2px;
      z-index: 9999;
      padding: 10px 15px;
      font-size: 16px;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    @media (max-width: 600px) {
      #back {
        font-size: 18px;
        padding: 12px 18px;
      }
    }

    #graph-container {
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <button id="back" onclick="location.href='./'">戻る</button>
  <div id="graph" style="width:100%;height:80vh;"></div>
  <script>
    //チャート
    const graphDiv = document.getElementById('graph');
    // サーバのAPI
    const apiUrl = "https://boxpush.d4df816be9225fab.workers.dev/data2";
    // x軸の単位(一分)
    const ONE_UNIT = 60 * 1000;
    // x軸の範囲(一日)
    const XRANGE = (24) * 60 * 60 * 1000;
    // id -> trace index の対応
    let traceIndexMap = {};
    // リクエスト済み範囲を管理するリスト
    let requestedRanges = [];
    // 再入阻止フラグ
    let fetching = false;


    const legend = {
      orientation: "v",
      x: 1,
      xanchor: "left",
      y: 0.95,          // 1 より大きい値で外側へ
      yanchor: "top"
    }
    /**
     * 範囲リストに追加する
     * @param {number} xmin - リクエスト開始値
     * @param {number} xmax - リクエスト終了値
     */
    function add_requested_range(xmin, xmax) {
      xmin /= ONE_UNIT;
      xmax /= ONE_UNIT;
      requestedRanges.push([xmin, xmax]);
      // 範囲リストをマージ
      requestedRanges = mergeRanges(requestedRanges);
    }

    /**
     * 開始値、終了値を丸める
     * @param {number} xmin - リクエスト開始値
     * @param {number} xmax - リクエスト終了値
     * @returns {[number, number]} 丸めた値
     */
    function round_range(xmin, xmax) {
      xmin = Math.floor(xmin / ONE_UNIT) * ONE_UNIT;
      xmax = Math.ceil(xmax / ONE_UNIT) * ONE_UNIT;
      return [xmin, xmax];
    }
    /**
     * 既存リクエスト範囲を除外しリクエスト範囲を縮小する
     * @param {Array<[number, number]>} requestedRanges - 既存のリクエスト済み範囲
     * @param {number} xmin - リクエスト開始値
     * @param {number} xmax - リクエスト終了値
     * @returns {[number|null, number|null]} 新しい範囲 (存在しなければ [null, null])
     */
    function getUnrequestedRange(requestedRanges, xmin, xmax) {
      let start = xmin / ONE_UNIT;
      let end = xmax / ONE_UNIT;
      let newStart = start;
      let newEnd = end;

      for (const [rStart, rEnd] of requestedRanges) {
        if (start >= rStart && end <= rEnd) {
          return [null, null];
        }
        if (rStart <= newStart && newStart <= rEnd) {
          newStart = rEnd + 1;
        }
        if (rStart <= newEnd && newEnd <= rEnd) {
          newEnd = rStart - 1;
        }
      }
      if (newStart > newEnd) {
        return [null, null];
      }
      newStart *= ONE_UNIT;
      newEnd *= ONE_UNIT;
      return [newStart, newEnd];
    }
    /**
     * 重なりや隣接するリクエスト範囲を統合した結果を返す
     * @param {Array<[number, number]>} requestedRanges
     * @returns {Array<[number, number]>} 統合後の範囲リスト
     */
    function mergeRanges(requestedRanges) {
      if (!requestedRanges || requestedRanges.length === 0) {
        return [];
      }

      // 開始位置でソート
      const sorted = [...requestedRanges].sort((a, b) => a[0] - b[0]);
      const merged = [sorted[0]];

      for (let i = 1; i < sorted.length; i++) {
        const [currentStart, currentEnd] = sorted[i];
        const [lastStart, lastEnd] = merged[merged.length - 1];

        // 重なり or 隣接している場合
        if (currentStart <= lastEnd + 1) {
          merged[merged.length - 1] = [lastStart, Math.max(lastEnd, currentEnd)];
        } else {
          merged.push([currentStart, currentEnd]);
        }
      }
      return merged;
    }

    // 初回の描画
    async function initPlot() {
      //描画範囲
      let now = Date.now();
      //      const [xmin, xmax] = round_range(now - XRANGE, now);
      const [xmin, xmax] = round_range(now - XRANGE, now);
      //サーバにデータリクエスト
      const res = await fetch(`${apiUrl}?start=${xmin}&end=${xmax}`);
      const buffer = await res.arrayBuffer();
      const data = MessagePack.decode(new Uint8Array(buffer));
      const traces = [];
      traceIndexMap = {};
      // 取得した範囲を保存
      add_requested_range(xmin, xmax);

      let idx = 0;
      data.forEach(d => {
        if (!(d.i in traceIndexMap)) {
          traceIndexMap[d.i] = idx++;
          traces.push({
            x: [],
            y: [],
            mode: "lines+markers",
            name: d.n,
            line: { width: 1 },
            marker: { size: 2 }
          });
        }
        const t = traces[traceIndexMap[d.i]];
        t.x.push(d.x);
        t.y.push(d.y);
      });
      const config = {
        locale: "ja",
        displayModeBar: true,
        displaylogo: false,
        modeBarButtonsToRemove: [
          'zoom2d', 'pan2d', 'select2d', 'lasso2d',
          'resetScale2d', 'hoverClosestCartesian', 'hoverCompareCartesian',
          'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'toggleSpikelines',
          'toggleHover', 'resetViews', 'editInChartStudio'
        ],
        modeBarButtonsToAdd: ['toImage'],
        responsive: true
      };

      const layout = {
        legend: legend,
        dragmode: "pan",
        hovermode: "closest",
        margin: { t: 0 },
        xaxis: {
          title: "東京市場",
          type: "date",
          range: [xmin, xmax],
          dtick: 3600 * 1000,
          tickformat: "%H:%M\n%Y/%m/%d",
          ticklabelmode: "period",
          autorange: false,
          fixedrange: false,
          rangeslider: { visible: false }
        },
        yaxis: {
          title: "4825",
          tickformat: ",d",
          autorange: true,
          fixedrange: true,
          rangemode: "tozero"
        },
        width: window.innerWidth,
        height: window.innerHeight
      };
      // グラフ描画
      Plotly.newPlot(graphDiv, traces, layout, config);

      // ユーザー操作で範囲が変わったときのコールバック
      graphDiv.on('plotly_relayout', (eventData) => {
        if (!eventData['xaxis.range[0]'] || !eventData['xaxis.range[1]']) return;
        let start = new Date(eventData['xaxis.range[0]']).getTime();
        let end = new Date(eventData['xaxis.range[1]']).getTime();
        const now = Date.now();
        // 右端が現在時刻を超えないようにする
        if (end > now) {
          end = now;
          start = end - XRANGE;
          Plotly.relayout(graphDiv, { 'xaxis.range': [start, end] });
        }
        safeFetchAndAppend(start, end);

      });
    }

    function updateLegendByXrange(gd) {
      const xrange = gd.layout.xaxis?.range;
      if (!xrange) return;
      const [xmin, xmax] = xrange.map(v => new Date(v).getTime());

      gd.data.forEach(trace => {
        const xs = Array.from(trace.x || []).map(v => new Date(v).getTime());
        const visible = xs.some(x => x >= xmin && x <= xmax);
        trace.showlegend = visible;
      });

      Plotly.react(gd, gd.data, gd.layout);
    }

    // 再入させないラッパー関数
    async function safeFetchAndAppend(start, end) {
      if (fetching) return;
      fetching = true;
      try {
        await fetchAndAppend(start, end);
      } finally {
        fetching = false;
      }
    }

    /**
     * 再描画処理
     * @param {number} start - リクエスト開始値
     * @param {number} end - リクエスト終了値
     */
    async function fetchAndAppend(start, end) {
      // 丸める
      [start, end] = round_range(start, end);
      // 既存範囲を除外
      [start, end] = getUnrequestedRange(requestedRanges, start, end);
      if (!start || !end) return;

      // サーバにデータリクエスト
      const res = await fetch(`${apiUrl}?start=${start}&end=${end}`);
      const buffer = await res.arrayBuffer();
      const data = MessagePack.decode(new Uint8Array(buffer));
      if (data.length === 0) return;

      // 取得した範囲を保存
      add_requested_range(start, end);

      // 新しい trace をまとめて追加
      const newTraces = [];
      data.forEach(d => {
        if (!(d.i in traceIndexMap)) {
          const newIndex = Object.keys(traceIndexMap).length;
          traceIndexMap[d.i] = newIndex;
          newTraces.push({
            x: [d.x],
            y: [d.y],
            mode: "lines+markers",
            name: d.n,
            line: { width: 1 },
            marker: { size: 2 }
          });
        }
      });

      if (newTraces.length > 0) {
        await Plotly.addTraces(graphDiv, newTraces);
      }

      // 既存 trace のデータマージ
      for (const [id, idx] of Object.entries(traceIndexMap)) {
        const trace = graphDiv.data[idx];
        if (!trace) continue;

        const oldPoints = (trace.x || []).map((x, i) => ({
          x,
          y: (trace.y || [])[i] ?? null
        }));

        const newPoints = data
          .filter(d => d.i == id)
          .map(d => ({ x: d.x, y: d.y }));

        if (newPoints.length === 0) continue;

        const merged = oldPoints.concat(newPoints);
        merged.sort((a, b) => a.x - b.x);

        trace.x = merged.map(p => p.x);
        trace.y = merged.map(p => p.y);
      }

      // 安全に全体を再描画
      Plotly.react(graphDiv, graphDiv.data, graphDiv.layout);
      updateLegendByXrange(graphDiv);
    }
    // 初期化
    initPlot();
    // 1分ごとに自動更新
    setInterval(() => {
      const now = Date.now();
      let end = new Date(graphDiv.layout.xaxis.range[1]).getTime();
      if (end < now) {
        Plotly.relayout(graphDiv, { "xaxis.range": [now - XRANGE, now] });
        safeFetchAndAppend(end, now);
      }
    }, 60 * 1000);

  </script>
</body>

</html>